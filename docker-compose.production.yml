version: '3.8'

# Production Docker Compose with Enhanced Security and Audit Trails
# Usage: docker-compose -f docker-compose.yml -f docker-compose.production.yml up

services:
  postgres:
    environment:
      # Enhanced PostgreSQL configuration for production
      POSTGRES_DB: trading_db
      POSTGRES_USER: trader
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-trading_secure_password_2024}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C --auth-host=md5"

      # Audit and compliance settings
      PGAUDIT_LOG: "write,ddl,role"
      PGAUDIT_LOG_CATALOG: "on"
      PGAUDIT_LOG_PARAMETER: "on"
      PGAUDIT_LOG_STATEMENT_ONCE: "on"

      # Performance tuning for production workload
      POSTGRES_MAX_CONNECTIONS: 300
      POSTGRES_SHARED_BUFFERS: 512MB
      POSTGRES_EFFECTIVE_CACHE_SIZE: 2GB
      POSTGRES_WORK_MEM: 8MB
      POSTGRES_MAINTENANCE_WORK_MEM: 128MB
      POSTGRES_CHECKPOINT_COMPLETION_TARGET: 0.9
      POSTGRES_WAL_BUFFERS: 32MB
      POSTGRES_DEFAULT_STATISTICS_TARGET: 100
      POSTGRES_RANDOM_PAGE_COST: 1.1
      POSTGRES_EFFECTIVE_IO_CONCURRENCY: 300

    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/01-init-db.sql:ro
      - ./init.sql:/docker-entrypoint-initdb.d/02-schema.sql:ro
      - ./sql/audit_trails.sql:/docker-entrypoint-initdb.d/03-audit-trails.sql:ro
      - ./backups:/backups
      - ./logs/postgres:/var/log/postgresql
      # SSL certificates for production (mount your certificates)
      # - ./certs/server.crt:/var/lib/postgresql/server.crt:ro
      # - ./certs/server.key:/var/lib/postgresql/server.key:ro

    ports:
      - "${POSTGRES_PORT:-5432}:5432"

    command: >
      postgres
      -c max_connections=300
      -c shared_buffers=512MB
      -c effective_cache_size=2GB
      -c work_mem=8MB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=32MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=300
      -c max_wal_size=2GB
      -c min_wal_size=1GB
      -c wal_compression=on
      -c wal_level=replica
      -c archive_mode=on
      -c archive_command='cp %p /backups/wal/%f'
      -c log_destination=stderr,csvlog
      -c log_statement=mod
      -c log_duration=on
      -c log_connections=on
      -c log_disconnections=on
      -c log_checkpoints=on
      -c log_lock_waits=on
      -c log_temp_files=0
      -c log_autovacuum_min_duration=0
      -c log_line_prefix='%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
      -c timezone=UTC
      -c shared_preload_libraries=pgaudit,pg_stat_statements
      -c pgaudit.log=write,ddl,role
      -c pgaudit.log_catalog=on
      -c pgaudit.log_parameter=on
      -c pgaudit.log_statement_once=on
      -c ssl=on
      -c ssl_cert_file=/var/lib/postgresql/server.crt
      -c ssl_key_file=/var/lib/postgresql/server.key
      -c ssl_ciphers='HIGH:MEDIUM:+3DES:!aNULL'
      -c ssl_prefer_server_ciphers=on

    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U trader -d trading_db && psql -U trader -d trading_db -c 'SELECT 1' > /dev/null"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

    restart: unless-stopped

    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'

  api:
    environment:
      # Production database connection with enhanced security
      DATABASE_URL: postgresql+asyncpg://trader:${POSTGRES_PASSWORD:-trading_secure_password_2024}@postgres:5432/trading_db?sslmode=require
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      POSTGRES_DB: trading_db
      POSTGRES_USER: trader
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-trading_secure_password_2024}

      # Enhanced connection pool settings for production
      POSTGRES_MIN_CONN: 10
      POSTGRES_MAX_CONN: 50
      POSTGRES_TIMEOUT: 60
      POSTGRES_CACHE_SIZE: 2048

      # Audit and compliance settings
      ENABLE_AUDIT_LOGGING: "true"
      AUDIT_USER_TRACKING: "true"
      ENABLE_QUERY_LOGGING: "false"  # Enable only if needed, high volume

      # Security settings
      POSTGRES_SSL_MODE: require
      SESSION_TIMEOUT_MINUTES: 30
      MAX_FAILED_LOGINS: 5
      REQUIRE_MFA: "false"  # Set to true when MFA is implemented

      # Application settings for production
      ENVIRONMENT: production
      LOG_LEVEL: INFO
      SQL_ECHO: false
      DEBUG: false

      # Security headers and CORS
      CORS_ORIGINS: "${CORS_ORIGINS:-http://localhost:3000,https://yourdomain.com}"
      SECRET_KEY: "${SECRET_KEY:-your-super-secret-key-change-in-production}"
      ALGORITHM: "HS256"

      # Performance settings
      UVICORN_WORKERS: 4
      UVICORN_WORKER_CONNECTIONS: 1000
      UVICORN_KEEPALIVE: 5
      UVICORN_ACCESS_LOG: "true"

      # Rate limiting
      RATE_LIMIT_ENABLED: "true"
      RATE_LIMIT_REQUESTS: 100
      RATE_LIMIT_WINDOW: 60

    volumes:
      - ./src:/app/src:ro
      - ./config:/app/config:ro
      - ./logs/api:/app/logs
      - ./reports:/app/reports
      # SSL certificates for API if needed
      # - ./certs/api.crt:/app/certs/api.crt:ro
      # - ./certs/api.key:/app/certs/api.key:ro

    ports:
      - "${API_PORT:-8000}:8000"

    depends_on:
      postgres:
        condition: service_healthy

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

    restart: unless-stopped

    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.25'

  # Redis for caching and session management
  redis:
    environment:
      # Redis configuration for production
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_secure_password_2024}

    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD:-redis_secure_password_2024}
      --appendonly yes
      --auto-aof-rewrite-percentage 100
      --auto-aof-rewrite-min-size 64mb
      --maxmemory 512mb
      --maxmemory-policy allkeys-lru
      --timeout 300
      --tcp-keepalive 60
      --save 900 1
      --save 300 10
      --save 60 10000

    volumes:
      - redis_data:/data
      - ./logs/redis:/var/log/redis
      - ./backups/redis:/backups

    restart: unless-stopped

    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.1'

  # Nginx reverse proxy with security headers
  nginx:
    image: nginx:alpine
    container_name: trading_nginx_prod
    restart: unless-stopped

    ports:
      - "80:80"
      - "443:443"

    volumes:
      - ./config/nginx/nginx.prod.conf:/etc/nginx/nginx.conf:ro
      - ./config/nginx/security.conf:/etc/nginx/security.conf:ro
      - ./logs/nginx:/var/log/nginx
      - ./static:/var/www/static:ro
      # SSL certificates
      # - ./certs/fullchain.pem:/etc/nginx/ssl/fullchain.pem:ro
      # - ./certs/privkey.pem:/etc/nginx/ssl/privkey.pem:ro

    depends_on:
      - api

    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3

    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.2'

  # Database backup service
  db_backup:
    image: postgres:15
    container_name: trading_db_backup
    restart: "no"  # Run manually or via cron

    environment:
      PGPASSWORD: ${POSTGRES_PASSWORD:-trading_secure_password_2024}

    volumes:
      - ./backups/database:/backups
      - ./scripts/backup_db.sh:/backup_db.sh:ro

    command: >
      sh -c "
        echo 'Database backup service ready'
        while true; do
          sleep 86400  # Sleep for 24 hours
          pg_dump -h postgres -U trader -d trading_db -F c -b -v -f /backups/trading_db_$(date +%Y%m%d_%H%M%S).backup
          find /backups -name '*.backup' -mtime +7 -delete  # Keep backups for 7 days
        done
      "

    depends_on:
      postgres:
        condition: service_healthy

    profiles:
      - backup

  # Log aggregation service (optional)
  logstash:
    image: docker.elastic.co/logstash/logstash:8.11.0
    container_name: trading_logstash
    restart: unless-stopped

    volumes:
      - ./config/logstash/logstash.conf:/usr/share/logstash/pipeline/logstash.conf:ro
      - ./logs:/logs:ro

    environment:
      LS_JAVA_OPTS: "-Xmx512m -Xms512m"

    ports:
      - "5044:5044"

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9600/_node/stats"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

    profiles:
      - logging

    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'

  # Monitoring service with Prometheus
  prometheus:
    image: prom/prometheus:latest
    container_name: trading_prometheus
    restart: unless-stopped

    ports:
      - "9090:9090"

    volumes:
      - ./config/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus

    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'

    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9090/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

    profiles:
      - monitoring

    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./data/postgres

  redis_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./data/redis

  prometheus_data:
    driver: local

networks:
  trading_network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
          gateway: 172.20.0.1

# Development override to disable production features
# Use: docker-compose -f docker-compose.yml -f docker-compose.production.yml -f docker-compose.dev.yml up
