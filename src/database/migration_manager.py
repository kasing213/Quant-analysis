"""
Database Migration Management for Quantitative Trading System
Provides utilities for managing database schema changes and migrations
"""

import asyncio
import os
import subprocess
import logging
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime

from alembic import command
from alembic.config import Config
from alembic.script import ScriptDirectory
from alembic.runtime.migration import MigrationContext
from alembic.operations import Operations

from .pg_config import PostgreSQLManager, DatabaseConfig

logger = logging.getLogger(__name__)

class MigrationManager:
    """Manages database migrations for the trading system"""

    def __init__(self, config: Optional[DatabaseConfig] = None):
        self.config = config or DatabaseConfig()
        self.pg_manager = PostgreSQLManager(self.config)

        # Set up Alembic configuration
        self.alembic_cfg_path = Path(__file__).parent / "alembic.ini"
        self.migrations_dir = Path(__file__).parent / "migrations"

        if not self.alembic_cfg_path.exists():
            raise FileNotFoundError(f"Alembic config not found: {self.alembic_cfg_path}")

    def get_alembic_config(self) -> Config:
        """Get Alembic configuration with current database URL"""
        alembic_cfg = Config(str(self.alembic_cfg_path))
        alembic_cfg.set_main_option("sqlalchemy.url", self.config.connection_string)
        alembic_cfg.set_main_option("script_location", str(self.migrations_dir))
        return alembic_cfg

    async def initialize_alembic(self) -> None:
        """Initialize Alembic for the project"""
        try:
            alembic_cfg = self.get_alembic_config()

            # Check if migrations directory exists and has content
            if not self.migrations_dir.exists() or not list(self.migrations_dir.glob("*.py")):
                logger.info("Initializing Alembic migrations...")
                command.init(alembic_cfg, str(self.migrations_dir))
                logger.info("Alembic initialized successfully")
            else:
                logger.info("Alembic already initialized")

        except Exception as e:
            logger.error(f"Failed to initialize Alembic: {e}")
            raise

    async def create_migration(self, message: str, autogenerate: bool = True) -> str:
        """Create a new migration"""
        try:
            alembic_cfg = self.get_alembic_config()

            # Create migration
            if autogenerate:
                logger.info(f"Creating autogenerated migration: {message}")
                revision = command.revision(
                    alembic_cfg,
                    message=message,
                    autogenerate=True
                )
            else:
                logger.info(f"Creating empty migration: {message}")
                revision = command.revision(
                    alembic_cfg,
                    message=message
                )

            logger.info(f"Migration created successfully: {revision}")
            return revision

        except Exception as e:
            logger.error(f"Failed to create migration: {e}")
            raise

    async def run_migrations(self, target_revision: str = "head") -> None:
        """Run migrations to target revision"""
        try:
            alembic_cfg = self.get_alembic_config()

            logger.info(f"Running migrations to: {target_revision}")
            command.upgrade(alembic_cfg, target_revision)
            logger.info("Migrations completed successfully")

        except Exception as e:
            logger.error(f"Failed to run migrations: {e}")
            raise

    async def downgrade_migration(self, target_revision: str) -> None:
        """Downgrade to specific revision"""
        try:
            alembic_cfg = self.get_alembic_config()

            logger.info(f"Downgrading to: {target_revision}")
            command.downgrade(alembic_cfg, target_revision)
            logger.info("Downgrade completed successfully")

        except Exception as e:
            logger.error(f"Failed to downgrade: {e}")
            raise

    async def get_migration_history(self) -> List[Dict[str, Any]]:
        """Get migration history"""
        try:
            await self.pg_manager.initialize()

            query = """
            SELECT
                version_num,
                upgrade_sql,
                downgrade_sql,
                applied_at
            FROM alembic_version_history
            ORDER BY applied_at DESC
            """

            history = await self.pg_manager.execute_query(query)
            return history

        except Exception as e:
            logger.error(f"Failed to get migration history: {e}")
            return []

    async def get_current_revision(self) -> Optional[str]:
        """Get current database revision"""
        try:
            await self.pg_manager.initialize()

            query = "SELECT version_num FROM trading.alembic_version"
            result = await self.pg_manager.execute_query(query)

            if result:
                return result[0]['version_num']
            return None

        except Exception as e:
            logger.warning(f"Could not get current revision: {e}")
            return None

    async def get_pending_migrations(self) -> List[str]:
        """Get list of pending migrations"""
        try:
            alembic_cfg = self.get_alembic_config()
            script = ScriptDirectory.from_config(alembic_cfg)

            current_rev = await self.get_current_revision()

            if current_rev is None:
                # No migrations applied yet
                return [rev.revision for rev in script.walk_revisions()]

            pending = []
            for rev in script.walk_revisions(current_rev, "head"):
                if rev.revision != current_rev:
                    pending.append(rev.revision)

            return pending

        except Exception as e:
            logger.error(f"Failed to get pending migrations: {e}")
            return []

    async def validate_database_schema(self) -> Dict[str, Any]:
        """Validate current database schema against models"""
        try:
            await self.pg_manager.initialize()

            # Get table information from database
            tables_info = await self.pg_manager.get_table_info('trading')

            # Check for required tables
            required_tables = [
                'accounts', 'positions', 'trades',
                'portfolio_summary', 'market_data', 'risk_events'
            ]

            existing_tables = list(tables_info.keys())
            missing_tables = [table for table in required_tables if table not in existing_tables]

            validation_result = {
                "valid": len(missing_tables) == 0,
                "existing_tables": existing_tables,
                "missing_tables": missing_tables,
                "total_tables": len(existing_tables),
                "required_tables": len(required_tables),
                "schema_info": tables_info
            }

            return validation_result

        except Exception as e:
            logger.error(f"Schema validation failed: {e}")
            return {
                "valid": False,
                "error": str(e),
                "existing_tables": [],
                "missing_tables": [],
                "total_tables": 0
            }

    async def backup_database(self, backup_name: Optional[str] = None) -> str:
        """Create database backup before migrations"""
        try:
            if backup_name is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_name = f"trading_db_backup_{timestamp}"

            backup_file = f"/tmp/{backup_name}.sql"

            # Use pg_dump to create backup
            cmd = [
                "pg_dump",
                "-h", self.config.host,
                "-p", str(self.config.port),
                "-U", self.config.username,
                "-d", self.config.database,
                "-f", backup_file,
                "--verbose"
            ]

            env = os.environ.copy()
            env["PGPASSWORD"] = self.config.password

            result = subprocess.run(cmd, env=env, capture_output=True, text=True)

            if result.returncode == 0:
                logger.info(f"Database backup created: {backup_file}")
                return backup_file
            else:
                raise Exception(f"Backup failed: {result.stderr}")

        except Exception as e:
            logger.error(f"Failed to create backup: {e}")
            raise

    async def restore_database(self, backup_file: str) -> None:
        """Restore database from backup"""
        try:
            if not os.path.exists(backup_file):
                raise FileNotFoundError(f"Backup file not found: {backup_file}")

            # Use psql to restore backup
            cmd = [
                "psql",
                "-h", self.config.host,
                "-p", str(self.config.port),
                "-U", self.config.username,
                "-d", self.config.database,
                "-f", backup_file,
                "--verbose"
            ]

            env = os.environ.copy()
            env["PGPASSWORD"] = self.config.password

            result = subprocess.run(cmd, env=env, capture_output=True, text=True)

            if result.returncode == 0:
                logger.info(f"Database restored from: {backup_file}")
            else:
                raise Exception(f"Restore failed: {result.stderr}")

        except Exception as e:
            logger.error(f"Failed to restore database: {e}")
            raise

# Convenience functions for CLI usage
async def init_migrations(config: Optional[DatabaseConfig] = None):
    """Initialize migration system"""
    manager = MigrationManager(config)
    await manager.initialize_alembic()

async def create_migration(message: str, config: Optional[DatabaseConfig] = None):
    """Create new migration"""
    manager = MigrationManager(config)
    return await manager.create_migration(message)

async def apply_migrations(config: Optional[DatabaseConfig] = None):
    """Apply all pending migrations"""
    manager = MigrationManager(config)
    await manager.run_migrations()

async def validate_schema(config: Optional[DatabaseConfig] = None):
    """Validate database schema"""
    manager = MigrationManager(config)
    return await manager.validate_database_schema()

if __name__ == "__main__":
    import sys

    async def main():
        if len(sys.argv) < 2:
            print("Usage: python migration_manager.py <command> [args]")
            print("Commands: init, create <message>, apply, validate")
            return

        command = sys.argv[1]

        if command == "init":
            await init_migrations()
        elif command == "create" and len(sys.argv) > 2:
            message = " ".join(sys.argv[2:])
            await create_migration(message)
        elif command == "apply":
            await apply_migrations()
        elif command == "validate":
            result = await validate_schema()
            print(f"Schema validation: {result}")
        else:
            print("Unknown command")

    asyncio.run(main())